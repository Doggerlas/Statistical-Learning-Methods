//#include "stdafx.h" 
#include <stdio.h>

char alpha[10][8][8] = {//定义十个二维数组 0-9号
 { // 0
  { 0, 0, 0, 0, 8, 8, 8, 8 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 }
 },
 { // 1
  { 0, 0, 0, 0, 8, 8, 8, 8 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 }
 },
 { // 2
  { 0, 0, 0, 0, 8, 8, 8, 8 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 8, 8, 8 }
 },
 { // 3
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 0, 0, 0 },
  { 0, 0, 0, 0, 8, 8, 8, 8 }
 },
 { // 4
  { 8, 8, 8, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 }
 },
 { // 5
  { 8, 8, 8, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 }
 },
 { // 6
  { 8, 8, 8, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 8, 8, 8, 8, 0, 0, 0, 0 }
 },
 { // 7
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 0, 0, 0, 8, 0, 0, 0, 0 },
  { 8, 8, 8, 8, 0, 0, 0, 0 }
 },
 { // 8
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 8, 0, 0, 8, 0, 0 },
  { 0, 0, 8, 0, 0, 8, 0, 0 },
  { 0, 0, 8, 0, 0, 8, 0, 0 },
  { 0, 0, 8, 8, 8, 8, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 }
 },
 { // 9
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 8, 8, 8, 8, 0, 0 },
  { 0, 0, 8, 0, 0, 8, 0, 0 },
  { 0, 0, 8, 0, 0, 8, 0, 0 },
  { 0, 0, 8, 0, 0, 8, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0 }
 }
};


static int dummy1[12];

static int dummy2[34];

static int dummy3[56];


static int seed;

static char photo[16][64];








/*******************************************************************************************************************
函数功能：打印photo
	photo待打印数组
*******************************************************************************************************************/
void printphot(char photo[16][64])
{
	for (int i = 0; i < 16; i++)
	{
		for (int j = 0; j < 64; j++)
		{
			printf("%d ", photo[i][j]);
		}
		printf("\n");
	}
}


/*******************************************************************************************************************
函数功能：用n号二维数组对photo中的初始坐标为(by,bx)右下角的8*8区域进行填充
	n-在alpha中选中的n号二维数组
	by,bx为photo中的初始坐标（填充原点）
*******************************************************************************************************************/
static void bitblt(int bx, int by, int n)
{
 for (int y = 0; y < 8; y++)
  for (int x = 0; x < 8; x++)
   photo[by + y][bx + x] = alpha[n][y][x];
}


/*******************************************************************************************************************
函数功能：产生随机整数，范围为0-32767 [(2^0-1)到(2^15-1)] 这种随机数产生方式比rand()快
*******************************************************************************************************************/
static int pseudo_rand(void)
{
 seed = seed * 214013 + 2531011;
 return (seed >> 16) & 0x7FFF;//表示产生的随机数只要后15位，所以最大的为二进制111111111111111即32768
}


/*******************************************************************************************************************
函数功能：随机产生四个像素原点坐标，对右下角8*8矩阵进行填充，填充的二维矩阵标号分别对应n的千、百、十、个位
	n；四位数字，不够用0填充
*******************************************************************************************************************/
static void shot(int n)
{
//将photo清空，所有值归零
 for (int y = 0; y < 16; y++)
  for (int x = 0; x < 64; x++)
   photo[y][x] = 0;

 int cursor = 0;
 int pos = 1000;
/*
改写photo数组，随机生成四个起始点坐标,并对这四个坐标右下角的8*8区域进行填充，填充块标号为入参(n / pos) % 10

*/
 for (int c = 0; c < 4; c++)
 {
  cursor += pseudo_rand() % 9;//产生0-8随机数

  int x = cursor;
  int y = pseudo_rand() % 9;

  bitblt(x, y, (n / pos) % 10);
  printf("shot第%d次循环产生的坐标为(%d,%d),块号为%d\n",c,x,y,(n / pos) % 10);

  cursor += 8;
  pos /= 10;
 }
 printf("未加入噪音的photo=\n");
 printphot(photo); 
/*
随机产生噪音，进行0-8翻转
对photo中每个位置随机数进行判断，若此处随机数为10的倍数，看这个位置的值是否为0，是0则重写为8，非01则改写为0（进行数字改变）；若此处随机数不为10的倍数，不进行操作*/

 for (int y = 0; y < 16; y++)
 {
	 for (int x = 0; x < 64; x++)
	 {
		 if (pseudo_rand() % 10 == 0)
		 {
			 photo[y][x] = (photo[y][x] == 0) ? 8 : 0;
			 //printf("噪音产生的位置为(%d,%d)，此处原位置数据为%d\n",y,x,(photo[y][x] == 0) ? 8 : 0);
		 }
	 }
 }
 printf("--------------------------------------------------------------------------------------------------------------------------------\n");
 printf("加入噪音的photo=\n");
 printphot(photo); 

}

/*******************************************************************************************************************
函数功能：二值图像降噪
	nz8：画布上某8邻近3*3区域内，若8的个数小于nz8则此8被视为噪音
	nz0：画布上某0邻近3*3区域内，若0的个数小于nz0则此0被视为噪音
*******************************************************************************************************************/
void RemoveNoise(int nz8,int nz0, char photo[16][64])
{
   for (int i = 0; i < 16; i++)
   {
       for (int j = 0; j < 64; j++)
       {

	       if(photo[i][j]==0)//如果噪声是0
           {
			/*   int nCount = 0;
				 for (int m = i-1; m <= i+1; ++m)
				  {
					 for (int n = j-1; n <= j+1; ++n)
					 {
						 if(photo[m][n]==0)
							 nCount++;
					 }
				  }
				 if (nCount <= nz0)
					 photo[i][j]=8;
			*/
			int nCount = 0;
			if(photo[i-1][j]==8 ||  photo[i+1][j]==8 ||  photo[i][j-1]==8 || photo[i][j+1]==8 ){nCount++;}
			if (nCount >= 2)
				 photo[i][j]=8;
           }

		   else//判断8是否为噪声：在以此数字为中心3*3蒙版内计算几个8,若此数字小于pNum则视作噪声，此位置8变成0
           {
/*
			   int nCount = 0;
               for (int m = i-1; m <= i+1; ++m)
               	{
                   for (int n = j-1; n <= j+1; ++n)
                   {
                       if(photo[m][n]==8)
                       nCount++;
                   }
               	}
               if (nCount <= nz8)
                   photo[i][j]=0;
*/
			   if((photo[i-2][j]==8 & photo[i-1][j]==8) || (photo[i+2][j]==8 & photo[i+1][j]==8) || (photo[i][j-2]==8 & photo[i][j-1]==8) || (photo[i][j+1]==8 & photo[i][j+2]==8))
			   {photo[i][j]=8;}
			   else
			   {photo[i][j]=0;}
           }
		   

       	}
   	}
   	 printf("--------------------------------------------------------------------------------------------------------------------------------\n");
	 printf("降噪后的photo=\n");
	 printphot(photo);
}

/*******************************************************************************************************************
函数功能：去除噪音，识别出块，返回识别出的块标号所组成的四位数 
	photo(16*64)数组
	返回值：识别出的块标号所组成的四位数
*******************************************************************************************************************/
extern int recog(char photo[16][64]);




static char fliter[8][8];//8*8数组滤镜
/*******************************************************************************************************************
函数功能：依次取alpha数组中0-9这十个8*8二维数组为滤镜
	num：选取的第几个alpha二维数组

*******************************************************************************************************************/
void getFliter(int num)
{
 	for (int i = 0; i < 8; i++){
	  		for (int j = 0; j < 8; j++){
	  			fliter[i][j] = 0;
	  		}
 	}

	 for (int i = 0; i < 8; i++){
	  		for (int j = 0; j < 8; j++){
	  			fliter[i][j] = alpha[num][i][j];
	  		}
 	}

	 printf("当前是第%d号数组滤镜\n",num);
	 for (int i = 0; i < 8; i++){
			 for (int j = 0; j < 8; j++){
				 printf("%d ", fliter[i][j]);
			 }
			 printf("\n");
		 }
}

 /*******************************************************************************************************************
 函数功能：找出dot_result数组前三最大值及其坐标
   num：选取的第几个alpha二维数组
 *******************************************************************************************************************/
void findTop3MaxinDot_result(int a[8][56]){
   	 int max1=a[0][0],m1x=0,m1y=0;
	 int max2=a[0][0],m2x=0,m2y=0;
	 int max3=a[0][0],m3x=0,m3y=0;
	 for (int i=0;i<8;i++)
	 {
	     for (int j=0;j<56;j++)
	     {
	         if (max1<=a[i][j])
	         {
	             max1=a[i][j];
	             m1x=i;
	             m1y=j;
	         }
			 else if (max2<=a[i][j]<max1) 
			 {
	             max2=a[i][j];
	             m2x=i;
	             m2y=j;
	         }
			  else if (max3<=a[i][j]<max2) 
			 {
	             max3=a[i][j];
	             m3x=i;
	             m3y=j;
	         }
			  else{}

	     }
	 }
	 		printf("max1=%d,x=%d,y=%d\n",max1,m1x,m1x);
			  printf("max2=%d,x=%d,y=%d\n",max2,m2x,m2x);
			  printf("max3=%d,x=%d,y=%d\n",max3,m3x,m3x);
}


int dot_result[8][56];//8*8数组滤镜
/*******************************************************************************************************************
函数功能：fliter对photo进行类卷积网络点积运算，计算出每个8*8矩阵权值，得到一个8*56的矩阵
	num：选取的第几个alpha二维数组
*******************************************************************************************************************/
void dotCalculate()
{
	//这里的ij指的是滤镜左上角的原点在滑动过程中对应的坐标变化
	for(int i=0;i<8;++i){
		for(int j=0;j<56;++j){
			//photo原点每移动一次对应的左下角8*8矩阵
			char temp[8][8];
            for (int m = i; m < i+8; ++m)
            	{
	                for (int n = j; n < j+8; ++n)
	                {
	                    temp[m-i][n-j]=photo[m][n];
						//printf("%d ", temp[m-i][n-j]);

	                }
            	}

	/*		printf("xasasdasdasd\n");
			for (int i = 0; i < 8; i++){
			 for (int j = 0; j < 8; j++){

				 printf("%d ", temp[i][j]);
			 }
			 printf("\n");
		 }*/

			//计算temp与fliter点积
			int dot=0;
			for(int a=0;a<8;a++){
				for (int b=0;b<8;b++){
					dot+=int(temp[a][b])*int(fliter[a][b]);
				}
			}
		dot_result[i][j]=dot;
		}
	}
	//打印dot_result
	printf("dayindot\n");
	for (int c = 0; c < 8; c++)
	{
		for (int d = 0; d < 56; d++)
		{
			printf("%d ", dot_result[c][d]);
		}
		printf("\n");
	}
	findTop3MaxinDot_result(dot_result);
}



int main(void)
{
 //int i,j;
 seed = 3;  // the seed will be changed  


 int RESULT = 0;
 for (int c = 0; c < 2; c++)
 {
  printf("------------------------------------------------------\n");
  int number = pseudo_rand() % 10000;//产生0-9999随机数
  printf("本次为第%d次循环\n", c);
  printf("本次循环number=%d\n", number);
  shot(number);
  RemoveNoise(2,5,photo);
  for(int i=0;i<10;i++){
  	//获取0-9号滤镜fliter
  	getFliter(i);
	//每个滤镜对photo进行矩阵点积运算
	dotCalculate();
  	findTop3MaxinDot_result(dot_result);
  }
 
  if (1)
  {
	  //printf("本次循环生成的photo=\n");
	  //printphot(photo);
	  //ress = recog(photo);
	  //printf("识别结果ress=%d\n", ress);

  }
#if 0
  else
  {
	  ress = recog(photo);
  }

  if (ress == number)
  {
	  RESULT++;//如果识别出的数字与输入输入的number相等则result+1
  }
  
  else 
  {
      //printf("number = %d \n",number); 
   if (0) 
   {        
	   printf("\n");
	   for (i = 0; i<16; i++)
	   {
		   for (j = 0; j<64; j++)
		   {
			   if (photo[i][j] == 0)
			   {
				   printf(" %c", '_');
			   }
			   else
			   {
				   printf(" %c", '8');
			   }
		   }
		   printf("\n");
	   }
   }
   ress= number ;  
  } 
#endif
}
 //printf("RESULT : %d\n", RESULT);//输出最终分数，满分为2000分，即在随机噪声感扰下能准确识别出几个由number生成的4个块
 return 0;
}


